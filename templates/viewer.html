{% extends "base.html" %}
{% block title %}3D Viewer{% endblock %}

{% block content %}
  <div class="viewer-wrap"
       style="height:70vh;position:relative;border:1px solid #1f2937;border-radius:12px;overflow:hidden">
    <div id="viewer"
         style="position:absolute;inset:0;width:100%;height:100%;
                touch-action:none;overscroll-behavior:contain;-webkit-user-select:none;user-select:none;"></div>

    <div id="status"
         style="position:absolute;top:10px;right:10px;background:#0f172a;opacity:.92;
                padding:.35rem .6rem;border-radius:999px;border:1px solid #334155;
                font:12px/1.2 system-ui;max-width:52ch;z-index:20">
      Booting…
    </div>

    <div class="toolbar" id="toolbar">
      <button id="btnPivot" class="tb active" aria-pressed="true">Pivot</button>
      <button id="btnPan"   class="tb">Pan</button>
      <button id="btnZoom"  class="tb">Zoom</button>
      <button id="btnReset" class="tb">Reset</button>
      <button id="btnGrid"  class="tb">Grid</button>
    </div>
  </div>
  <p style="margin-top:.75rem;color:#64748b;margin-bottom:0">
    Mode is <em>exclusive</em>. Drag with finger/trackpad/mouse to perform the selected action.
  </p>

  <style>
    .toolbar {
      position: absolute; left: 0; right: 0; bottom: 10px;
      display: flex; gap: .5rem; justify-content: center;
      padding: .4rem .6rem; background: #0b0f14cc; backdrop-filter: blur(6px);
      border: 1px solid #334155; border-radius: 12px;
      margin: 0 auto; width: fit-content; z-index: 30;
      max-width: calc(100% - 20px);
    }
    .tb {
      background:#0f172a; color:#cbd5e1;
      border:1px solid #334155; border-radius:10px;
      padding:.5rem .7rem; font:13px/1 system-ui; cursor:pointer;
      min-width:64px; text-align:center;
    }
    .tb.active { background:#14213a; border-color:#3b82f6; color:#e2e8f0; }
    .tb:active { transform:translateY(1px); }
    @media (hover:hover) { .tb:hover { background:#14213a; } }
    @media (min-width: 760px) {
      .toolbar { left: 10px; right: auto; bottom: auto; top: 10px; justify-content: flex-start; }
    }
  </style>
{% endblock %}

{% block extra_scripts %}
  <script type="importmap">
  {
    "imports": {
      "three": "/static/vendor/three.module.js",
      "three/addons/": "/static/vendor/addons/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    // Your GitHub *blob* URL (we convert it to raw automatically)
    const GH_BLOB_URL = "https://github.com/ZanderDent/445/blob/main/static/our_design.stl";

    // View tweaks
    const TWEAK = {
      zUpToYUp: true,
      rotationDeg: { x: 0, y: 0, z: 100 },
      offset: { x: 0, y: 0, z: 0 },
      normalizeTo: 80,
      scale: 1,
      cameraBias: { x: 0, y: 0, z: 0 },
      pivotOffset: { x: 0, y: 0, z: 0 },
      padding: 1.35
    };

    const container = document.getElementById('viewer');
    const statusEl  = document.getElementById('status');

    const btnPivot = document.getElementById('btnPivot');
    const btnPan   = document.getElementById('btnPan');
    const btnZoom  = document.getElementById('btnZoom');
    const btnReset = document.getElementById('btnReset');
    const btnGrid  = document.getElementById('btnGrid');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 1e9);
    camera.position.set(2.5, 1.8, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.screenSpacePanning = true;
    controls.zoomToCursor = true;
    controls.zoomSpeed = 0.4;
    controls.panSpeed  = 0.9;
    controls.rotateSpeed = 0.9;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x263238, 0.95));
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(5,10,7);
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 20, 0x334155, 0x1f2937);
    grid.position.y = -0.0001;
    scene.add(grid);

    function resize(){
      const r = container.getBoundingClientRect();
      const w = Math.max(1, r.width), h = Math.max(1, r.height);
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize, { passive:true });

    function fitTo(obj, {
      padding = TWEAK.padding,
      pivotOffset = new THREE.Vector3(TWEAK.pivotOffset.x, TWEAK.pivotOffset.y, TWEAK.pivotOffset.z),
      cameraBias  = new THREE.Vector3(TWEAK.cameraBias.x,  TWEAK.cameraBias.y,  TWEAK.cameraBias.z)
    } = {}) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3()).add(pivotOffset);
      const maxDim = Math.max(size.x,size.y,size.z) || 1;

      const fitDist = maxDim / (2 * Math.tan(Math.PI * camera.fov / 360));
      const diagDir = new THREE.Vector3(1,1,1).normalize();

      camera.position.copy(center)
        .add(diagDir.multiplyScalar(fitDist * padding))
        .add(cameraBias);

      camera.near = Math.max(0.001, maxDim / 1000);
      camera.far  = Math.max(2000, fitDist * 50);
      camera.updateProjectionMatrix();

      controls.target.copy(center);
      controls.minDistance = Math.max(maxDim * 0.01, 0.001);
      controls.maxDistance = fitDist * 50;
      controls.update();
    }

    const loader = new STLLoader();
    const material = new THREE.MeshStandardMaterial({
      color: 0xb9c6d3, metalness: 0.05, roughness: 0.7, side: THREE.DoubleSide
    });

    const group = new THREE.Group();
    scene.add(group);

    function clearAndAdd(obj){
      while (group.children.length) group.remove(group.children[0]);
      group.add(obj);
      fitTo(group);
      resize();
      statusEl.textContent = 'Loaded ✓';
    }

    function normalizeAndTweak(mesh){
      if (TWEAK.normalizeTo && TWEAK.normalizeTo > 0) {
        const box = new THREE.Box3().setFromObject(mesh);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const s = TWEAK.normalizeTo / maxDim;
        mesh.scale.multiplyScalar(s);
      }
      if (TWEAK.scale !== 1) mesh.scale.multiplyScalar(TWEAK.scale);
      if (TWEAK.zUpToYUp)    mesh.rotation.x += -Math.PI / 2;

      mesh.rotation.x += THREE.MathUtils.degToRad(TWEAK.rotationDeg.x);
      mesh.rotation.y += THREE.MathUtils.degToRad(TWEAK.rotationDeg.y);
      mesh.rotation.z += THREE.MathUtils.degToRad(TWEAK.rotationDeg.z);

      mesh.position.add(new THREE.Vector3(TWEAK.offset.x, TWEAK.offset.y, TWEAK.offset.z));
    }

    // Turn a GitHub "blob" URL into a "raw" URL
    function toRawFromBlob(blobUrl){
      // https://github.com/owner/repo/blob/branch/path -> https://raw.githubusercontent.com/owner/repo/branch/path
      const m = blobUrl.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
      if (m){
        const [, owner, repo, branch, path] = m;
        return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
      }
      return blobUrl; // already raw or something else
    }

    // Stream the STL in chunks with an optional throttle to be gentle
    async function streamFetchToArrayBuffer(url, { throttleMs = 40 } = {}){
      const res = await fetch(url, { cache: 'no-store', mode: 'cors' });
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);

      const contentLength = Number(res.headers.get('content-length') || 0);
      const reader = res.body.getReader();
      const chunks = [];
      let received = 0;

      statusEl.textContent = 'Fetching…';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
        received += value.byteLength;

        if (contentLength) {
          const pct = ((received / contentLength) * 100).toFixed(1);
          statusEl.textContent = `Downloading… ${pct}%`;
        } else {
          statusEl.textContent = `Downloading… ${Math.round(received/1024/1024)} MB`;
        }

        if (throttleMs > 0) {
          await new Promise(r => setTimeout(r, throttleMs));
        }
      }

      let total = received;
      const out = new Uint8Array(total);
      let offset = 0;
      for (const c of chunks) {
        out.set(c, offset);
        offset += c.byteLength;
      }
      return out.buffer;
    }

    async function loadSTLFromArrayBuffer(buf){
      // guard against HTML (e.g., wrong URL)
      const head = new Uint8Array(buf.slice(0, 256));
      const headStr = new TextDecoder('ascii', { fatal: false }).decode(head).toLowerCase();
      if (headStr.includes('<html') || headStr.includes('<!doctype')) {
        throw new Error('Got HTML instead of STL. Use a RAW URL (this page converts your blob URL automatically).');
      }

      statusEl.textContent = 'Parsing…';
      const geometry = loader.parse(buf);
      geometry.computeVertexNormals();
      geometry.center();

      const mesh = new THREE.Mesh(geometry, material);
      normalizeAndTweak(mesh);
      clearAndAdd(mesh);
    }

    async function loadGithubBlob(blobUrl){
      try {
        const rawUrl = toRawFromBlob(blobUrl);
        const buf = await streamFetchToArrayBuffer(rawUrl, { throttleMs: 40 }); // adjust if needed
        await loadSTLFromArrayBuffer(buf);
      } catch (err) {
        console.error(err);
        statusEl.textContent = `Error loading STL — ${String(err.message || err)}`;
      }
    }

    // Kick off load from your provided URL
    loadGithubBlob(GH_BLOB_URL);

    // ---- Controls modes ----
    const MOUSE = THREE.MOUSE;
    function setActive(btn){ [btnPivot,btnPan,btnZoom,btnReset,btnGrid].forEach(b=>b.classList.remove('active')); btn.classList.add('active'); }
    function setMode(mode){
      if (mode==='pivot'){
        controls.enableRotate=true;controls.enablePan=false;controls.enableZoom=false;
        controls.mouseButtons={LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.ROTATE,RIGHT:MOUSE.ROTATE,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.ROTATE};
        controls.zoomSpeed=0.15; setActive(btnPivot); statusEl.textContent='Mode: Pivot';
      } else if (mode==='pan'){
        controls.enableRotate=false;controls.enablePan=true;controls.enableZoom=false;
        controls.mouseButtons={LEFT:MOUSE.PAN,MIDDLE:MOUSE.PAN,RIGHT:MOUSE.PAN,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.PAN,TWO:THREE.TOUCH.PAN};
        controls.zoomSpeed=0.15; setActive(btnPan); statusEl.textContent='Mode: Pan';
      } else if (mode==='zoom'){
        controls.enableRotate=false;controls.enablePan=false;controls.enableZoom=true;
        controls.mouseButtons={LEFT:MOUSE.DOLLY,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.DOLLY,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.DOLLY_PAN,TWO:THREE.TOUCH.DOLLY_PAN};
        controls.zoomSpeed=0.10; setActive(btnZoom); statusEl.textContent='Mode: Zoom';
      }
    }
    btnPivot.onclick=()=>setMode('pivot');
    btnPan.onclick  =()=>setMode('pan');
    btnZoom.onclick =()=>setMode('zoom');

    btnReset.onclick = ()=>{
      const mesh = group.children[0];
      if (!mesh) return;
      mesh.position.set(0,0,0);
      mesh.rotation.set(0,0,0);
      mesh.scale.set(1,1,1);
      normalizeAndTweak(mesh);
      fitTo(group);
      setMode('pivot');
      statusEl.textContent = 'View reset (centered & fit)';
    };

    btnGrid.onclick = ()=>{ grid.visible = !grid.visible; };

    function loop(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); }
    resize(); loop();
  </script>
{% endblock %}
