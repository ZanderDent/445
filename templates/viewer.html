{% extends "base.html" %}
{% block title %}3D Viewer{% endblock %}

{% block content %}
  <div class="viewer-wrap"
       style="height:70vh;position:relative;border:1px solid #1f2937;border-radius:12px;overflow:hidden">
    <div id="viewer"
         style="position:absolute;inset:0;width:100%;height:100%;
                touch-action:none;overscroll-behavior:contain;-webkit-user-select:none;user-select:none;"></div>

    <div id="status"
         style="position:absolute;top:10px;right:10px;background:#0f172a;opacity:.92;
                padding:.35rem .6rem;border-radius:999px;border:1px solid #334155;
                font:12px/1.2 system-ui;max-width:52ch;z-index:20">
      Booting…
    </div>

    <div class="toolbar" id="toolbar">
      <button id="btnPivot" class="tb active" aria-pressed="true">Pivot</button>
      <button id="btnPan"   class="tb">Pan</button>
      <button id="btnZoom"  class="tb">Zoom</button>
      <button id="btnReset" class="tb">Reset</button>
      <button id="btnGrid"  class="tb">Grid</button>
    </div>
  </div>
  <p style="margin-top:.75rem;color:#64748b;margin-bottom:0">
    Mode is <em>exclusive</em>. Drag with finger/trackpad/mouse to perform the selected action.
  </p>

  <style>
    .toolbar {
      position: absolute; left: 0; right: 0; bottom: 10px;
      display: flex; gap: .5rem; justify-content: center;
      padding: .4rem .6rem; background: #0b0f14cc; backdrop-filter: blur(6px);
      border: 1px solid #334155; border-radius: 12px;
      margin: 0 auto; width: fit-content; z-index: 30;
      max-width: calc(100% - 20px);
    }
    .tb {
      background:#0f172a; color:#cbd5e1;
      border:1px solid #334155; border-radius:10px;
      padding:.5rem .7rem; font:13px/1 system-ui; cursor:pointer;
      min-width:64px; text-align:center;
    }
    .tb.active { background:#14213a; border-color:#3b82f6; color:#e2e8f0; }
    .tb:active { transform:translateY(1px); }
    @media (hover:hover) { .tb:hover { background:#14213a; } }
    @media (min-width: 760px) {
      .toolbar { left: 10px; right: auto; bottom: auto; top: 10px; justify-content: flex-start; }
    }
  </style>
{% endblock %}

{% block extra_scripts %}
  <!-- Minimal local ESM -->
  <script type="importmap">
  {
    "imports": {
      "three": "/static/vendor/three.module.js",
      "three/addons/": "/static/vendor/addons/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { STLLoader } from 'three/addons/loaders/STLLoader.js';

    // ------------ HARD-CODED VIEW TWEAKS (edit these) ------------
    const TWEAK = {
      // Your CAD is Z-up → make it Y-up for three.js
      zUpToYUp: true,                   // rotate X by -90°

      // Make the long span horizontal: rotate ~90° around Z
      // (If it’s the wrong way, flip the sign to -90)
      rotationDeg: { x: 0, y: 0, z: 100 },

      // After centering, nudge if needed (usually keep 0s)
      offset: { x: 0, y: 0, z: 0 },

      // Auto-normalize the model so its largest dimension = N scene units.
      // This guarantees it fills the view nicely regardless of STL units.
      normalizeTo: 50,   // try 50 (or 100). Set to 0 to disable.

      // If you additionally want a fixed multiplier after normalization
      scale: 1,          // keep 1 unless you want a little extra

      // Where to aim the camera relative to the model center (optional)
      cameraBias: { x: 0, y: 0, z: 0 },

      // Shift the orbit pivot relative to the model center (optional)
      pivotOffset: { x: 500, y: -200, z: -500 },

      // How tight the initial fit is (smaller = closer)
      padding: 1.25
    };

    // -------------------------------------------------------------

    const container = document.getElementById('viewer');
    const statusEl  = document.getElementById('status');

    const btnPivot = document.getElementById('btnPivot');
    const btnPan   = document.getElementById('btnPan');
    const btnZoom  = document.getElementById('btnZoom');
    const btnReset = document.getElementById('btnReset');
    const btnGrid  = document.getElementById('btnGrid');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);

    const camera = new THREE.PerspectiveCamera(60, 2, 0.01, 1e9);
    camera.position.set(2.5, 1.8, 3.2);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.screenSpacePanning = true;
    controls.zoomToCursor = true;
    controls.zoomSpeed = 0.15;
    controls.panSpeed  = 0.9;
    controls.rotateSpeed = 0.9;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x263238, 0.95));
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(5,10,7);
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 20, 0x334155, 0x1f2937);
    grid.position.y = -0.0001;
    scene.add(grid);

    function resize(){
      const r = container.getBoundingClientRect();
      const w = Math.max(1, r.width), h = Math.max(1, r.height);
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize, { passive:true });

    function fitTo(obj, {
      padding = TWEAK.padding,
      pivotOffset = new THREE.Vector3(TWEAK.pivotOffset.x, TWEAK.pivotOffset.y, TWEAK.pivotOffset.z),
      cameraBias  = new THREE.Vector3(TWEAK.cameraBias.x,  TWEAK.cameraBias.y,  TWEAK.cameraBias.z)
    } = {}) {
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3()).add(pivotOffset);
      const maxDim = Math.max(size.x,size.y,size.z) || 1;

      const fitDist = maxDim / (2 * Math.tan(Math.PI * camera.fov / 360));
      const diagDir = new THREE.Vector3(1,1,1).normalize();

      camera.position.copy(center)
        .add(diagDir.multiplyScalar(fitDist * padding))
        .add(cameraBias);

      camera.near = Math.max(0.001, maxDim / 1000);
      camera.far  = Math.max(2000, fitDist * 50);
      camera.updateProjectionMatrix();

      controls.target.copy(center);
      controls.minDistance = Math.max(maxDim * 0.01, 0.001);
      controls.maxDistance = fitDist * 50;
      controls.update();
    }

    const MODEL_URL = "{{ model_url|default('/static/our_design.stl')|safe }}";
    const loader = new STLLoader();
    const material = new THREE.MeshStandardMaterial({
      color: 0xb9c6d3, metalness: 0.05, roughness: 0.7, side: THREE.DoubleSide
    });

    let model = null; // Group

    loader.load(
      MODEL_URL,
      (geometry)=>{
        // Normalize geometry around origin (this truly centers it)
        geometry.computeVertexNormals();
        geometry.center(); // << puts the mesh's local origin at the bbox center

        const mesh = new THREE.Mesh(geometry, material);

        // Apply hardcoded tweaks in this order: scale → up-axis fix → extra rotation → offset
        if (TWEAK.scale !== 1) mesh.scale.setScalar(TWEAK.scale);
        if (TWEAK.zUpToYUp)    mesh.rotation.x += -Math.PI / 2;

        mesh.rotation.x += THREE.MathUtils.degToRad(TWEAK.rotationDeg.x);
        mesh.rotation.y += THREE.MathUtils.degToRad(TWEAK.rotationDeg.y);
        mesh.rotation.z += THREE.MathUtils.degToRad(TWEAK.rotationDeg.z);

        mesh.position.add(new THREE.Vector3(TWEAK.offset.x, TWEAK.offset.y, TWEAK.offset.z));

        model = new THREE.Group();
        model.add(mesh);
        scene.add(model);

        // Fit AFTER transforms so it appears dead-center
        fitTo(model);
        resize();
        statusEl.textContent = 'Loaded ✓';
      },
      (xhr)=>{
        if (xhr.total) statusEl.textContent = `Loading… ${(xhr.loaded/xhr.total*100).toFixed(0)}%`;
      },
      (err)=>{
        console.error(err);
        statusEl.textContent = 'Error loading STL';
      }
    );

    // ---- Modes (exclusive) ----
    const MOUSE = THREE.MOUSE;
    function setActive(btn){ [btnPivot,btnPan,btnZoom,btnReset,btnGrid].forEach(b=>b.classList.remove('active')); btn.classList.add('active'); }
    function setMode(mode){
      if (mode==='pivot'){
        controls.enableRotate=true;controls.enablePan=false;controls.enableZoom=false;
        controls.mouseButtons={LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.ROTATE,RIGHT:MOUSE.ROTATE,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.ROTATE};
        controls.zoomSpeed=0.15; setActive(btnPivot); statusEl.textContent='Mode: Pivot';
      } else if (mode==='pan'){
        controls.enableRotate=false;controls.enablePan=true;controls.enableZoom=false;
        controls.mouseButtons={LEFT:MOUSE.PAN,MIDDLE:MOUSE.PAN,RIGHT:MOUSE.PAN,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.PAN,TWO:THREE.TOUCH.PAN};
        controls.zoomSpeed=0.15; setActive(btnPan); statusEl.textContent='Mode: Pan';
      } else if (mode==='zoom'){
        controls.enableRotate=false;controls.enablePan=false;controls.enableZoom=true;
        controls.mouseButtons={LEFT:MOUSE.DOLLY,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.DOLLY,WHEEL:MOUSE.WHEEL};
        controls.touches={ONE:THREE.TOUCH.DOLLY_PAN,TWO:THREE.TOUCH.DOLLY_PAN};
        controls.zoomSpeed=0.10; setActive(btnZoom); statusEl.textContent='Mode: Zoom';
      }
    }
    btnPivot.onclick=()=>setMode('pivot');
    btnPan.onclick  =()=>setMode('pan');
    btnZoom.onclick =()=>setMode('zoom');

    // Reset = re-apply hardcoded tweaks + re-fit (guaranteed center)
    btnReset.onclick = ()=>{
      if (!model) return;
      // undo transforms first
      const mesh = model.children[0];
      mesh.position.set(0,0,0);
      mesh.rotation.set(0,0,0);
      mesh.scale.set(1,1,1);

      if (TWEAK.scale !== 1) mesh.scale.setScalar(TWEAK.scale);
      if (TWEAK.zUpToYUp)    mesh.rotation.x += -Math.PI / 2;
      mesh.rotation.x += THREE.MathUtils.degToRad(TWEAK.rotationDeg.x);
      mesh.rotation.y += THREE.MathUtils.degToRad(TWEAK.rotationDeg.y);
      mesh.rotation.z += THREE.MathUtils.degToRad(TWEAK.rotationDeg.z);
      mesh.position.add(new THREE.Vector3(TWEAK.offset.x, TWEAK.offset.y, TWEAK.offset.z));

      fitTo(model);
      setMode('pivot');
      statusEl.textContent = 'View reset (centered & fit)';
    };

    btnGrid.onclick = ()=>{ grid.visible = !grid.visible; };

    // Defaults + render
    setMode('pivot');
    function loop(){ controls.update(); renderer.render(scene,camera); requestAnimationFrame(loop); }
    resize(); loop();
  </script>
{% endblock %}
